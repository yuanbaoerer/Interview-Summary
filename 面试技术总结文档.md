# 面试技术总结文档



**ThreadLocal 底层实现**

> ThreadLocal 是 Java 中用于实现线程本地变量的工具，其核心是通过 **线程私有存储** 实现变量隔离。底层依赖 **Thread**类中的 **threadLocals** 变量（类型为 `ThreadLocal.ThreadLocalMap`）：
>
> - 每个线程持有自己的 `ThreadLocalMap`，该 Map 的 **key 是 ThreadLocal 实例（弱引用），value 是线程本地变量的值**
> - 当调用 `ThreadLocal.set(T value)` 时，实际是往当前线程的 `ThreadLocalMap` 中添加键值对；`get()` 则是从当前线程的 Map 中获取对应 value
> - 这种设计确保了每个线程操作的是自己的变量副本，避免线程安全问题。

**ThreadLocal 造成内存泄漏的原因**

内存泄露的核心是 `ThreadLocalMap 中的 value 无法被回收`，具体原因：

- `ThreadLocalMap`的 Entry 中，key（ThreadLocal 实例）是**弱引用**，当 ThreadLocal 实例外部没有强引用时，会被 GC 回收，此时 Entry 的 key 变为 null
- 但 Entry 的 value 是 **强引用**，若线程长期存活（如线程池的核心线程），value 会一直被线程引用，无法被 GC 回收，导致内存泄漏
- 解决方法：使用完 ThreadLocal 后，显式调用`remove()`方法清除 value，避免残留。

---

**B +树 红黑树 区别**

| 维度     | B + 树                                             | 红黑树                                              |
| -------- | -------------------------------------------------- | --------------------------------------------------- |
| 结构     | 多路平衡查找树（多叉树）                           | 二叉平衡查找树                                      |
| 节点存储 | 非叶子节点仅存索引，叶子节点存数据且按顺序链表连接 | 每个节点既存数据也存索引                            |
| 适用场景 | 磁盘存储（如 MySQL 索引）                          | 内存存储（如 Java HashMap）                         |
| 查找效率 | IO 次数少（层高低），范围查询高效（叶子节点链表）  | 插入 / 删除效率高（旋转次数少），范围查询需中序遍历 |

---

**Stream API 中 flatMap 和 map 的区别**

两者都是 Stream 的转换操作，核心区别在于 **输出结果的 “维度”**：

- `map(Function)`：对每个元素做 “一对一” 转换，输出的 Stream 与原 Stream 维度一致（如将 `Stream<String>` 转为 `Stream<Integer>`）。
- `flatMap(Function)`：对每个元素做 “一对多” 转换，并将结果 “扁平化”（如将 `Stream<List<Integer>>` 转为 `Stream<Integer>`），相当于先 map 再合并嵌套的 Stream。

---

**ReentrantLock 和 synchronized 的区别**

| 维度     | ReentrantLock（可重入锁）            | synchronized（同步关键字）                    |
| -------- | ------------------------------------ | --------------------------------------------- |
| 实现方式 | JDK 层面（Java 类）                  | JVM 层面（字节码指令）                        |
| 锁操作   | 显式调用 `lock()`/`unlock()`         | 隐式加锁 / 解锁（代码块结束自动释放）         |
| 功能扩展 | 支持公平锁、可中断锁、Condition 通知 | 仅支持非公平锁，通过 `wait()`/`notify()` 通知 |

---

**MySQL 查询优化**

核心思路是 **减少 IO 次数、利用索引、避免全表扫描**，常见手段：

- **索引优化：**给查询频繁的字段建立索引（如 where、join、order by 字段）；避免索引失效（如函数操作索引列、使用`!=/is null`、模糊查询前缀带 %）
- **SQL 语句优化：**避免 `select *`（只查需要的字段）；用 join 代替子查询；合理使用 limit 分页；避免 or（改用 union）
- **表结构优化：**按范式设计减少冗余；大表分表（水平/垂直分表）；用合适的字段类型（如 tinyint 代替 int）
- **执行计划分析：**通过 `explain`查看查询计划，重点关注`type`（是否用到索引，如`ref/range`优于`ALL`）、`rows`（扫描行数）
- **其他：**开启查询缓存（适用于读多写少场景）；优化 MySQL 配置（如 innodb_buffer_pool_size 调大缓存）
